#' @title Combine geographic set using the ACS package geo.make function
#' @description The \code{sumacs} function uses outputs from the
#'   \code{\link{acs}} package to compute proportions, ratios and aggregations
#'   based on text formulas, or simply extract variables. The function
#'   downloads the data and then estimate the formulas. If the function is used
#'   without specifying any \code{data}, remember to define a key using the
#'   \code{\link{acs}} command \code{api.key.install(key="*")}.
#' @param formula A character or vector of characters containing formulas using
#'   ACS variables or just variables. + - operators can be included. / defines a
#'   division. When the formula contains "* 100", the final statistic and MOE is
#'   multiply by 100.
#' @param varname A character or vector of characters containing the new
#'   variables to be created. This vector must have same length as
#'   \code{formula} and \code{method}, and it is not needed when getting only
#'   variables.
#' @param method A character or vector of characters defining the type of
#'   estimate expected: "proportion", "ratio", "aggregation", "variables". This
#'   vector must have same length as \code{formula} and \code{varname}. It is
#'   not needed when getting only variables.
#' @param level A character or vector of characters specifying the geographic
#'   level of the data. It may be necessary to specificy values to the
#'   corresponding levels. For instance, when \code{level = "county"}, you have
#'   to specify a state (e.g., \code{state = "WI"}, the default state in this
#'   package). You can also use a wildcard method (\code{state = "*"}) to
#'   include all the states. Below, you can see the required combinations of
#'   different summary levels.
#'
#'   \cr 010 us \cr 020 region \cr 030 division \cr 040 state \cr 050 state,
#'   county \cr 060 state, county, county.subdivision \cr 140 state, county,
#'   tract \cr 150 state, county, tract, block.group \cr 160 state, place \cr
#'   250 american.indian.area \cr 320 state, msa \cr 340 state, csa \cr 350
#'   necta \cr 400 urban.area \cr 500 state, congressional.district \cr 610
#'   state, state.legislative.district.upper \cr 620 state,
#'   state.legislative.district.lower \cr 795 state, puma \cr 860 zip.code \cr
#'   950 state, school.district.elementary \cr 960 state,
#'   school.district.secondary \cr 970 state, school.district.unified \cr
#'
#' @param endyear An integer (defaults to 2014  ) indicating the latest year of
#'   the data in the survey.
#' @param span An integer indicating the span (in years) of the desired ACS data
#'   (should be 1, 3, or 5), defaults to 5.
#' @param conf.level Confidence level to estimate MOEs. The default value is
#'   0.90.
#' @param one.zero Whether to include standard errors for only one zero-value
#'   (max value) of columns or all. The default is TRUE.
#' @param trace Shows progress of the variable creation. The default is TRUE.
#' @param data Input data generated by the \code{\link{acsdata}} function.
#'   Variables and levels must be the same as those specified in the
#'   \code{sumacs} function.
#' @param format.out Format of the output: "wide" or "long". The default is
#'   "wide".
#' @param file The resulting output is exported to a CSV file rather than to the
#'   R prompt. The file name must be specified as a character string.
#' @param combine Whether the geographies are to be combined when the data is downloaded. This will be applied to all the levels specified.
#' @param combine.name Label for the aggregate geography when data are combined. The default value is \code{aggregate}. This will be applied to all the levels specified.
#' @return Returns a \code{data.table/data.frame} object with the estimates and
#'   MOEs.
#' @details When the standard error of a proportion cannot be estimated, the
#'   "ratio" option is used. This adjustment is done row by row.
#' @note Depending on the quality of the internet connection, number of
#'   variables and levels, getting the ACS data can be slow, especially for the
#'   levels "county.subdivision", "block.group", and "tract" (it might take more
#'   than 30 minutes).  It is recommended to get the data using the function
#'   \code{\link{acsdata}} first, and then to use \code{sumacs}.
#' @examples
#' # api.key.install(key="*")
#' sumacs(formula = "(b16004_004 + b16004_026 + b16004_048 / b16004_001)", varname = "langspan0913", method = "prop")
combine.make.geo <- function(
  level,
  combine.name = "aggregate",
  region = "*",
  division = "*",
  state = "*",
  county = "*",
  county.subdivision ="*",
  place ="*",
  tract = "*",
  block.group = "*",
  msa = "*",
  csa = "*",
  necta = "*",
  urban.area = "*",
  congressional.district = "*",
  state.legislative.district.upper = "*",
  state.legislative.district.lower = "*",
  puma = "*",
  zip.code = "*",
  american.indian.area = "*",
  school.district.elementary = "*",
  school.district.secondary = "*",
  school.district.unified = "*"
) {

  # setting level variables

  if ( any(level %in% "region") & length(level) == 1 &  length(region) > 1 ) {
  if (!is.list(region)) { stop("region has to be a list when combining data!") }
  level <- rep(level, length(region))
  }

  if ( any(level %in% "division") & length(level) == 1 &  length(division) > 1 ) {
  if (!is.list(division)) { stop("division has to be a list when combining data!") }
  level <- rep(level, length(division))
  }

  if ( any(level %in% "necta") & length(level) == 1 &  length(necta) > 1 ) {
  if (!is.list(necta)) { stop("necta has to be a list when combining data!") }
  level <- rep(level, length(necta))
  }

  if ( any(level %in% "urban.area") & length(level) == 1 &  length(urban.area) > 1 ) {
  if (!is.list(urban.area)) { stop("urban.area has to be a list when combining data!") }
  level <- rep(level, length(urban.area))
  }

  if ( any(level %in% "zip.code") & length(level) == 1 &  length(zip.code) > 1 ) {
  if (!is.list(zip.code)) { stop("zip.code has to be a list when combining data!") }
  level <- rep(level, length(zip.code))
  }

  if ( any(level %in% "american.indian.area") & length(level) == 1 &  length(american.indian.area) > 1 ) {
  if (!is.list(american.indian.area)) { stop("american.indian.area has to be a list when combining data!") }
  level <- rep(level, length(american.indian.area))
  }

  if ( any(level %in% "state") & length(level) == 1 &  length(state) > 1 ) {
  if (!is.list(state)) { stop("state has to be a list when combining data!") }
  level <- rep(level, length(state))
  }

  if ( any(level %in% "county") & length(level) == 1 & length(state) == 1 &  length(county) > 1 ) {
  if (!is.list(county)) { stop("county has to be a list when combining data!") }
  level <- rep(level, length(county))
  state <- rep(state, length(county))
  }

  if ( any(level %in% "county.subdivision") & length(level) == 1 &  length(county.subdivision) > 1 ) {
  if (!is.list(county.subdivision)) { stop("county.subdivision has to be a list when combining data!") }
  level <- rep(level, length(county.subdivision))
  if ( length(state) == 1 ) { state <- rep(state, length(county.subdivision)) }
  if ( length(county) == 1 ) { county <- rep(state, length(county.subdivision)) }
  }

  if ( any(level %in% "tract") & length(level) == 1 &  length(tract) > 1 ) {
  if (!is.list(tract)) { stop("tract has to be a list when combining data!") }
  level <- rep(level, length(tract))
  if ( length(state) == 1 ) { state <- rep(state, length(tract)) }
  if ( length(county) == 1 ) { county <- rep(state, length(tract)) }
  }

  if ( any(level %in% "block.group") & length(level) == 1 & length(block.group) > 1 ) {
  if (!is.list(block.group)) { stop("block.group has to be a list when combining data!") }
  level <- rep(level, length(block.group))
  if ( length(state) == 1 ) { state <- rep(state, length(county)) }
  if ( length(county) == 1 ) { county <- rep(county, length(county)) }
  if ( length(tract) == 1 ) { tract <- rep(tract, length(county)) }
  }

  if ( any(level %in% "place") & length(level) == 1 & length(state) == 1 &  length(place) > 1 ) {
  if (!is.list(place)) { stop("place has to be a list when combining data!") }
  level <- rep(level, length(place))
  state <- rep(state, length(place))
  }

  if ( any(level %in% "msa") & length(level) == 1 & length(state) == 1 &  length(msa) > 1 ) {
  if (!is.list(msa)) { stop("msa has to be a list when combining data!") }
  level <- rep(level, length(msa))
  state <- rep(state, length(msa))
  }

  if ( any(level %in% "csa") & length(level) == 1 & length(state) == 1 &  length(csa) > 1 ) {
  if (!is.list(csa)) { stop("csa has to be a list when combining data!") }
  level <- rep(level, length(csa))
  state <- rep(state, length(csa))
  }

  if ( any(level %in% "puma") & length(level) == 1 & length(state) == 1 &  length(puma) > 1 ) {
  if (!is.list(puma)) { stop("puma has to be a list when combining data!") }
  level <- rep(level, length(puma))
  state <- rep(state, length(puma))
  }

  if ( any(level %in% "congressional.district") & length(level) == 1 & length(state) == 1 &  length(congressional.district) > 1 ) {
  if (!is.list(congressional.district)) { stop("congressional.district has to be a list when combining data!") }
  level <- rep(level, length(congressional.district))
  state <- rep(state, length(congressional.district))
  }

  if ( any(level %in% "state.legislative.district.lower") & length(level) == 1 & length(state) == 1 &  length(state.legislative.district.lower) > 1 ) {
  if (!is.list(state.legislative.district.lower)) { stop("state.legislative.district.lower has to be a list when combining data!") }
  level <- rep(level, length(state.legislative.district.lower))
  state <- rep(state, length(state.legislative.district.lower))
  }

  if ( any(level %in% "state.legislative.district.upper") & length(level) == 1 & length(state) == 1 &  length(state.legislative.district.upper) > 1 ) {
  if (!is.list(state.legislative.district.upper)) { stop("state.legislative.district.upper has to be a list when combining data!") }
  level <- rep(level, length(state.legislative.district.upper))
  state <- rep(state, length(state.legislative.district.upper))
  }

  if ( any(level %in% "school.district.elementary") & length(level) == 1 & length(state) == 1 &  length(school.district.elementary) > 1 ) {
    if (!is.list(school.district.elementary)) { stop("school.district.elementary has to be a list when combining data!") }
  level <- rep(level, length(school.district.elementary))
  state <- rep(state, length(school.district.elementary))
  }

  if ( any(level %in% "school.district.secondary") & length(level) == 1 & length(state) == 1 &  length(school.district.secondary) > 1 ) {
    if (!is.list(school.district.secondary)) { stop("school.district.secondary has to be a list when combining data!") }
  level <- rep(level, length(school.district.secondary))
  state <- rep(state, length(school.district.secondary))
  }

# end setting level variables

  # level output list
  geolist <- list()

  # level loop

  for ( l in seq_along(level) ) {

    # region

    if (level[l] == "region" ) {

       geolist[[l]] <- geo.make(region = region[[l]])
       }

    # division

    if (level[l] == "division" ) {

       geolist[[l]] <- geo.make(division = division[[l]])

       }


    # state

    if (level[l] == "state" ) {

       geolist[[l]] <- geo.make(state = state[[l]], check = TRUE)

       }

    # county

    if (level[l] == "county" ) {

       geolist[[l]] <- geo.make(state = state[[l]], county = county[[l]])

       }

    # county.subdivision

    if (level[l] == "county.subdivision" ) {

       geolist[[l]] <- geo.make(state = state[[l]], county = county[[l]], county.subdivision = county.subdivision[[l]])

       }

    # tract

    if (level[l] == "tract" ) {

       geolist[[l]] <- geo.make(state = state[[l]], county = county[[l]], tract = tract[[l]])

       }

    # block.group

    if (level[l] == "block.group" ) {

       geolist[[l]] <- geo.make(state = state[[l]], county = county[[l]], tract = tract[[l]], block.group = block.group[[l]], check = TRUE )

       }

    # place

    if (level[l] == "place" ) {

       geolist[[l]] <- geo.make(state = state[[l]], place = place[[l]])

       }

    # american.indian.area

    if (level[l] == "american.indian.area" ) {

       geolist[[l]] <- geo.make(american.indian.area = american.indian.area[[l]])

       }

    # congressional.district

    if (level[l] == "puma" ) {

       geolist[[l]] <- geo.make(state = state[[l]], puma = puma[[l]])

       }

    # csa

    if (level[l] == "csa" ) {

       geolist[[l]] <- geo.make(state = state[[l]], csa = csa[[l]])

       }

    # msa

    if (level[l] == "msa" ) {

       geolist[[l]] <- geo.make(state = state[[l]], msa = msa[[l]])

       }

    # necta

    if (level[l] == "necta" ) {

       geolist[[l]] <- geo.make(necta = necta[[l]])

       }

    # urban.area

    if (level[l] == "urban.area" ) {

       geolist[[l]] <- geo.make(urban.area = urban.area[[l]])

       }

    # zip.code

    if (level[l] == "zip.code" ) {

       geolist[[l]] <- geo.make(zip.code = zip.code[[l]])

       }

    # congressional.district

    if (level[l] == "congressional.district" ) {

       geolist[[l]] <- geo.make(state = state[[l]], congressional.district = congressional.district[[l]])

       }

    # state.legislative.district.lower

    if (level[l] == "state.legislative.district.lower" ) {

       geolist[[l]] <- geo.make(state = state[[l]], state.legislative.district.lower = state.legislative.district.lower[[l]])

       }

    # state.legislative.district.upper

    if (level[l] == "state.legislative.district.upper" ) {

       geolist[[l]] <- geo.make(state = state[[l]], state.legislative.district.upper = state.legislative.district.upper[[l]])

       }

    # school.district.elementary

    if (level[l] == "school.district.elementary" ) {

       geolist[[l]] <- geo.make(state = state[[l]], school.district.elementary = school.district.elementary[[l]])

       }

     # school.district.secondary

    if (level[l] == "school.district.secondary" ) {

       geolist[[l]] <- geo.make(state = state[[l]], school.district.secondary = school.district.secondary[[l]], check = TRUE)

       }


     } # end level loop

 tt <- Reduce("+", geolist)
 acs::combine(tt) <- TRUE
 acs::combine.term(tt) <- combine.name

  return(tt)

    } # end function
